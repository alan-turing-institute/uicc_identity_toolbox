#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# The Alan Turing Institute
# Chris Hicks 20-10-21
import sys
import numpy as np
np.set_printoptions(threshold=sys.maxsize)
import matplotlib.pyplot as plt
# version 5-L ! = 108 data code words (bytes), 106 after metadata/packing
# https://codegolf.stackexchange.com/questions/19970/qr-codes-and-all-that-jazz

### RS code stolen from https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#RS_generator_polynomial
gf_exp = [1] + [0] * 511
gf_log = [0] * 256
x = 1
for i in range(1,255):
    x <<= 1
    if x & 0x100:
        x ^= 0x11d
    gf_exp[i] = x
    gf_log[x] = i
for i in range(255,512):
    gf_exp[i] = gf_exp[i-255]


def gf_mul(x,y):
    if x==0 or y==0:
        return 0
    return gf_exp[gf_log[x] + gf_log[y]]

def main():
    s = sys.argv[1]

    nsyms = {1:7, 2:10, 3:15, 4:20, 5:26}
    max_msg_bytes = {1:19, 2:34, 3:55, 4:80, 5:108, 6:136, 7:156, 8:194, 9:232, 10: 274, 11: 324, 12: 370, 13: 428}

    version = 2
    mode = 4 # byte mode
    dim = 17 + 4 * version
    datamatrix = 2.0 * np.ones((dim, dim), dtype=np.int8)
    nsym = nsyms[version]
    padded_len = max_msg_bytes[version]

    # PACK
    msg = [mode * 16, len(s) * 16] + [ord(c) << 4 for c in s]
    for i in range(1, len(msg)):
        msg[i-1] += msg[i] // 256
        msg[i] = msg[i] % 256

    pad = [236, 17]
    msg = (msg + pad * 54)[:padded_len]

    # MAGIC (encoding)
    gen = [1]
    for i in range(0, nsym):
        q = [1, gf_exp[i]]
        r = [0] * (len(gen)+len(q)-1)
        for j in range(0, len(q)):
            for i in range(0, len(gen)):
                r[i+j] ^= gf_mul(gen[i], q[j])
        gen = r

    msg_enc = [0] * (len(msg) + nsym)
    for i in range(0, len(msg)):
        msg_enc[i] = msg[i]
    for i in range(0, len(msg)):
        coef = msg_enc[i]
        if coef != 0:
            for j in range(0, len(gen)):
                msg_enc[i+j] ^= gf_mul(gen[j], coef)
    for i in range(0, len(msg)):
        msg_enc[i] = msg[i]

    #print([hex(n) for n in msg_enc])

    # finder patterns (8x8 always)
    for _ in range(3):
        datamatrix = np.rot90(datamatrix)
        for i in range(4):
            datamatrix[max(0, i-1):8-i, max(0, i-1):8-i] = i%2
    datamatrix = np.rot90(datamatrix.T)

    # timing patterns (always row and column 6)
    for i in range(7, dim-7):
        datamatrix[i, 6] = datamatrix[6, i] = (i+1)%2
    
    # alignment patterns (grid of 5x5 excluding finder pattern corners)
    if version > 1:
        for i in range(3):
            datamatrix[8+(4*version)+i:13+(4*version)-i, 8+(4*version)+i:13+(4*version)-i] = (i+1)%2 

    # dummy format bit (constant across versions)
    datamatrix[dim-8, 8] = 1

    # FORMAT INFO
    L4 = '110011000101111' # Low/Mask4
    ptr_ul = np.array([8, -1])
    steps_ul = [0, 1] * 8 + [-1, 0] * 7
    steps_ul[13] = 2 # hop over vertical timing
    steps_ul[18] = -2 # then horizontal

    ptr_x = np.array([dim, 8])
    steps_x = [-1, 0] * 7 + [15-dim, dim-16] + [0, 1] * 7

    # Draw the actual format bits
    for bit, step_ul, step_x in zip(L4, np.array(steps_ul).reshape(-1,2), np.array(steps_x).reshape(-1,2)):
        ptr_ul += step_ul
        ptr_x += step_x
        datamatrix[tuple(ptr_ul)] = int(bit)
        datamatrix[tuple(ptr_x)] = int(bit)
    
    #print(datamatrix.flatten())
    #print( ''.join(['{}, '.format(int(b)) for b in datamatrix.flatten()]) )

    #datamatrix = np.array([1, 1, 1, 1, 1, 1, 1, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 1, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, 2, 2, 2, 2, 2, 2, 2, 1, 0, 1, 0, 1, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 1, 0, 1, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 1, 2, 2, 2, 2, 1, 0, 1, 1, 1, 0, 1, 0, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 0, 1, 1, 1, 0, 1, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 1, 1, 1, 0, 1, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 1, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])
    #print(datamatrix.size)
    #datamatrix = np.reshape(datamatrix, (dim,dim))
    #print(datamatrix.shape)

    # FILL
    dmask = datamatrix == 2.0

    cols = (dim-1)/2
    cursor = np.array([dim-1, dim]) # starting off the matrix

    #up_col = [-1, 1, 0, -1] * dim
    up_col = [0, 2, 1, 0] * dim
    #down_col = [1, 1, 0, -1] * dim
    down_col = [2, 2, 1, 0] * dim
    #steps = ([0, -1] + up_col[2:] + [0, -1] + down_col[2:]) * (cols/2)
    steps = ([1, 0] + up_col[2:] + [1, 0] + down_col[2:]) * (cols/2)

    steps = np.array(steps).reshape(-1, 2)
    steps = iter(steps)

    cursor_map = [624,  599,  623,  598,  622,  597,  621,  596,  620,  595,  619,  594,  618,  593,  617,  592,  616,  591,  615,  590,  614,  589,  613,  588,  612,  587,  611,  586,  610,  585,  609,  584,  608,  583,  607,  582,  606,  581,  605,  580,  604,  579,  603,  578,  602,  577,  601,  576,  600,  575,  550,  525,  551,  526,  552,  527,  553,  528,  554,  529,  555,  530,  556,  531,  557,  532,  558,  533,  559,  534,  560,  535,  561,  536,  562,  537,  563,  538,  564,  539,  565,  540,  566,  541,  567,  542,  568,  543,  569,  544,  570,  545,  571,  546,  572,  547,  573,  548,  574,  549,  524,  499,  523,  498,  522,  497,  521,  496,  520,  495,  519,  494,  518,  493,  517,  492,  516,  491,  515,  490,  514,  489,  513,  488,  512,  487,  511,  486,  510,  485,  509,  484,  508,  483,  507,  482,  506,  481,  505,  480,  504,  479,  503,  478,  502,  477,  501,  476,  500,  475,  450,  425,  451,  426,  452,  427,  453,  428,  454,  429,  455,  430,  456,  431,  457,  432,  458,  433,  459,  434,  460,  435,  461,  436,  462,  437,  463,  438,  464,  439,  465,  440,  466,  441,  467,  442,  468,  443,  469,  444,  470,  445,  471,  446,  472,  447,  473,  448,  474,  449,  424,  399,  423,  398,  422,  397,  421,  396,  420,  395,  419,  394,  418,  393,  417,  392,  416,  391,  415,  390,  414,  389,  413,  388,  412,  387,  411,  386,  410,  385,  409,  384,  408,  383,  407,  382,  406,  381,  405,  380,  404,  379,  403,  378,  402,  377,  401,  376,  400,  375,  350,  325,  351,  326,  352,  327,  353,  328,  354,  329,  355,  330,  356,  331,  357,  332,  358,  333,  359,  334,  360,  335,  361,  336,  362,  337,  363,  338,  364,  339,  365,  340,  366,  341,  367,  342,  368,  343,  369,  344,  370,  345,  371,  346,  372,  347,  373,  348,  374,  349,  324,  299,  323,  298,  322,  297,  321,  296,  320,  295,  319,  294,  318,  293,  317,  292,  316,  291,  315,  290,  314,  289,  313,  288,  312,  287,  311,  286,  310,  285,  309,  284,  308,  283,  307,  282,  306,  281,  305,  280,  304,  279,  303,  278,  302,  277,  301,  276,  300,  275,  250,  225,  251,  226,  252,  227,  253,  228,  254,  229,  255,  230,  256,  231,  257,  232,  258,  233,  259,  234,  260,  235,  261,  236,  262,  237,  263,  238,  264,  239,  265,  240,  266,  241,  267,  242,  268,  243,  269,  244,  270,  245,  271,  246,  272,  247,  273,  248,  274,  249,  224,  199,  223,  198,  222,  197,  221,  196,  220,  195,  219,  194,  218,  193,  217,  192,  216,  191,  215,  190,  214,  189,  213,  188,  212,  187,  211,  186,  210,  185,  209,  184,  208,  183,  207,  182,  206,  181,  205,  180,  204,  179,  203,  178,  202,  177,  201,  176,  200,  175,  150,  100,  126,  101,  127,  102,  128,  103,  129,  104,  130,  105,  131,  106,  132,  107,  133,  108,  134,  109,  135,  110,  136,  111,  137,  112,  138,  113,  139,  114,  140,  115,  141,  116,  142,  117,  143,  118,  144,  119,  145,  120,  146,  121,  147,  122,  148,  123,  149,  124,  99,  74,  98,  73,  97,  72,  96,  71,  95,  70,  94,  69,  93,  68,  92,  67,  91,  66,  90,  65,  89,  64,  88,  63,  87,  62,  86,  61,  85,  60,  84,  59,  83,  58,  82,  57,  81,  56,  80,  55,  79,  54,  78,  53,  77,  52,  76,  51,  75,  50,  25,  0,  26,  1,  27,  2,  28,  3,  29,  4,  30,  5,  31,  6,  32,  7,  33,  8,  34,  9,  35,  10,  36,  11,  37,  12,  38,  13,  39,  14,  40,  15,  41,  16]
    # # Work bit-wise on the encoded message
    msg_enc = ''.join('{:08b}'.format(x) for x in msg_enc) + '0' * 7 # 7 0's are for padding
    #print(msg_enc)
    for bit in msg_enc:
        collision = 'maybe'
        while collision:
            try:
                temp = steps.next()
                cursor[0] += temp[0]-1
                cursor[1] += temp[1]-1
                
            except StopIteration:
                break
            # skip vertical timing
            if cursor[1] == 6:
                cursor[1] = 5
            #print('{}, '.format(cursor[1]+dim*cursor[0])),
            collision = not dmask[tuple(cursor)]
        datamatrix[tuple(cursor)] = int(bit)
        #print(str(tuple(cursor)) + ':' + str(int(datamatrix[tuple(cursor)]))),

    # Apply mask pattern
    mask4 = lambda i, j: (i//2 + j//3)%2 == 0
    
    for i in range(dim):
        for j in range(dim): # Across the whole code
            #if mask4(i, j):
            #    print('true, '),
            #else:
            #    print('false, '),
            if dmask[i, j]:    
                datamatrix[i, j] = (int(datamatrix[i, j])&0x1 ^ (1 if mask4(i, j) else 0))
    
    #print(datamatrix)

    test = np.array([1,1,1,1,1,1,1,0,1,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,1,0,1,1,0,1,1,1,0,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1,1,1,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,1,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,1,1,0,1,1,0,0,1,1,1,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,0,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1])
    test = np.reshape(test, (dim,dim))

    # Draw binary array to screen
    plt.figure(facecolor='white')
    plt.imshow(datamatrix, cmap=plt.cm.gray_r, interpolation='nearest')
    plt.axis('off')
    plt.show()

if __name__ == '__main__':
    main()